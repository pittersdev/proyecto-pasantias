{"ast":null,"code":"import historyProvider from './historyProvider';\nvar supportedResolutions = [\"1\", \"3\", \"5\", \"15\", \"30\", \"60\", \"120\", \"240\", \"D\"];\nvar config = {\n  supported_resolutions: supportedResolutions\n};\nexport default {\n  onReady: function onReady(cb) {\n    console.log('=====onReady running');\n    setTimeout(function () {\n      return cb(config);\n    }, 0);\n  },\n  searchSymbols: function searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {\n    console.log('====Search Symbols running');\n  },\n  resolveSymbol: function resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {\n    // expects a symbolInfo object in response\n    console.log('======resolveSymbol running'); // console.log('resolveSymbol:',{symbolName})\n\n    var split_data = symbolName.split(/[:/]/); // console.log({split_data})\n\n    var symbol_stub = {\n      name: symbolName,\n      description: '',\n      type: 'crypto',\n      session: '24x7',\n      timezone: 'Etc/UTC',\n      ticker: symbolName,\n      exchange: split_data[0],\n      minmov: 1,\n      pricescale: 100000000,\n      has_intraday: true,\n      intraday_multipliers: ['1', '60'],\n      supported_resolution: supportedResolutions,\n      volume_precision: 8,\n      data_status: 'streaming'\n    };\n\n    if (split_data[2].match(/USD|EUR|JPY|AUD|GBP|KRW|CNY/)) {\n      symbol_stub.pricescale = 100;\n    }\n\n    setTimeout(function () {\n      onSymbolResolvedCallback(symbol_stub);\n      console.log('Resolving that symbol....', symbol_stub);\n    }, 0); // onResolveErrorCallback('Not feeling it today')\n  },\n  getBars: function getBars(symbolInfo, resolution, from, to, onHistoryCallback, onErrorCallback, firstDataRequest) {\n    console.log('=====getBars running'); // console.log('function args',arguments)\n    // console.log(`Requesting bars between ${new Date(from * 1000).toISOString()} and ${new Date(to * 1000).toISOString()}`)\n\n    historyProvider.getBars(symbolInfo, resolution, from, to, firstDataRequest).then(function (bars) {\n      if (bars.length) {\n        onHistoryCallback(bars, {\n          noData: false\n        });\n      } else {\n        onHistoryCallback(bars, {\n          noData: true\n        });\n      }\n    }).catch(function (err) {\n      console.log({\n        err: err\n      });\n      onErrorCallback(err);\n    });\n  },\n  subscribeBars: function subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) {\n    console.log('=====subscribeBars runnning');\n  },\n  unsubscribeBars: function unsubscribeBars(subscriberUID) {\n    console.log('=====unsubscribeBars running');\n  },\n  calculateHistoryDepth: function calculateHistoryDepth(resolution, resolutionBack, intervalBack) {\n    //optional\n    console.log('=====calculateHistoryDepth running'); // while optional, this makes sure we request 24 hours of minute data at a time\n    // CryptoCompare's minute data endpoint will throw an error if we request data beyond 7 days in the past, and return no data\n\n    return resolution < 60 ? {\n      resolutionBack: 'D',\n      intervalBack: '1'\n    } : undefined;\n  },\n  getMarks: function getMarks(symbolInfo, startDate, endDate, onDataCallback, resolution) {\n    //optional\n    console.log('=====getMarks running');\n  },\n  getTimeScaleMarks: function getTimeScaleMarks(symbolInfo, startDate, endDate, onDataCallback, resolution) {\n    //optional\n    console.log('=====getTimeScaleMarks running');\n  },\n  getServerTime: function getServerTime(cb) {\n    console.log('=====getServerTime running');\n  }\n};","map":{"version":3,"sources":["/home/luis/Documentos/GrafiTTraders/grafittraders/src/grafits/TVChartContainer/api/index.js"],"names":["historyProvider","supportedResolutions","config","supported_resolutions","onReady","cb","console","log","setTimeout","searchSymbols","userInput","exchange","symbolType","onResultReadyCallback","resolveSymbol","symbolName","onSymbolResolvedCallback","onResolveErrorCallback","split_data","split","symbol_stub","name","description","type","session","timezone","ticker","minmov","pricescale","has_intraday","intraday_multipliers","supported_resolution","volume_precision","data_status","match","getBars","symbolInfo","resolution","from","to","onHistoryCallback","onErrorCallback","firstDataRequest","then","bars","length","noData","catch","err","subscribeBars","onRealtimeCallback","subscribeUID","onResetCacheNeededCallback","unsubscribeBars","subscriberUID","calculateHistoryDepth","resolutionBack","intervalBack","undefined","getMarks","startDate","endDate","onDataCallback","getTimeScaleMarks","getServerTime"],"mappings":"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","sourcesContent":["import historyProvider from './historyProvider'\n\nconst supportedResolutions = [\"1\", \"3\", \"5\", \"15\", \"30\", \"60\", \"120\", \"240\", \"D\"]\n\nconst config = {\n    supported_resolutions: supportedResolutions\n}; \n\nexport default {\n\tonReady: cb => {\n\tconsole.log('=====onReady running')\t\n\t\tsetTimeout(() => cb(config), 0)\n\t\t\n\t},\n\tsearchSymbols: (userInput, exchange, symbolType, onResultReadyCallback) => {\n\t\tconsole.log('====Search Symbols running')\n\t},\n\tresolveSymbol: (symbolName, onSymbolResolvedCallback, onResolveErrorCallback) => {\n\t\t// expects a symbolInfo object in response\n\t\tconsole.log('======resolveSymbol running')\n\t\t// console.log('resolveSymbol:',{symbolName})\n\t\tvar split_data = symbolName.split(/[:/]/)\n\t\t// console.log({split_data})\n\t\tvar symbol_stub = {\n\t\t\tname: symbolName,\n\t\t\tdescription: '',\n\t\t\ttype: 'crypto',\n\t\t\tsession: '24x7',\n\t\t\ttimezone: 'Etc/UTC',\n\t\t\tticker: symbolName,\n\t\t\texchange: split_data[0],\n\t\t\tminmov: 1,\n\t\t\tpricescale: 100000000,\n\t\t\thas_intraday: true,\n\t\t\tintraday_multipliers: ['1', '60'],\n\t\t\tsupported_resolution:  supportedResolutions,\n\t\t\tvolume_precision: 8,\n\t\t\tdata_status: 'streaming',\n\t\t}\n\n\t\tif (split_data[2].match(/USD|EUR|JPY|AUD|GBP|KRW|CNY/)) {\n\t\t\tsymbol_stub.pricescale = 100\n\t\t}\n\t\tsetTimeout(function() {\n\t\t\tonSymbolResolvedCallback(symbol_stub)\n\t\t\tconsole.log('Resolving that symbol....', symbol_stub)\n\t\t}, 0)\n\t\t\n\t\t\n\t\t// onResolveErrorCallback('Not feeling it today')\n\n\t},\n\tgetBars: function(symbolInfo, resolution, from, to, onHistoryCallback, onErrorCallback, firstDataRequest) {\n\t\tconsole.log('=====getBars running')\n\t\t// console.log('function args',arguments)\n\t\t// console.log(`Requesting bars between ${new Date(from * 1000).toISOString()} and ${new Date(to * 1000).toISOString()}`)\n\t\thistoryProvider.getBars(symbolInfo, resolution, from, to, firstDataRequest)\n\t\t.then(bars => {\n\t\t\tif (bars.length) {\n\t\t\t\tonHistoryCallback(bars, {noData: false})\n\t\t\t} else {\n\t\t\t\tonHistoryCallback(bars, {noData: true})\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tconsole.log({err})\n\t\t\tonErrorCallback(err)\n\t\t})\n\n\t},\n\tsubscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) => {\n\t\tconsole.log('=====subscribeBars runnning')\n\t},\n\tunsubscribeBars: subscriberUID => {\n\t\tconsole.log('=====unsubscribeBars running')\n\t},\n\tcalculateHistoryDepth: (resolution, resolutionBack, intervalBack) => {\n\t\t//optional\n\t\tconsole.log('=====calculateHistoryDepth running')\n\t\t// while optional, this makes sure we request 24 hours of minute data at a time\n\t\t// CryptoCompare's minute data endpoint will throw an error if we request data beyond 7 days in the past, and return no data\n\t\treturn resolution < 60 ? {resolutionBack: 'D', intervalBack: '1'} : undefined\n\t},\n\tgetMarks: (symbolInfo, startDate, endDate, onDataCallback, resolution) => {\n\t\t//optional\n\t\tconsole.log('=====getMarks running')\n\t},\n\tgetTimeScaleMarks: (symbolInfo, startDate, endDate, onDataCallback, resolution) => {\n\t\t//optional\n\t\tconsole.log('=====getTimeScaleMarks running')\n\t},\n\tgetServerTime: cb => {\n\t\tconsole.log('=====getServerTime running')\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}